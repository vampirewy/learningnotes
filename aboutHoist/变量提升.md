<!--
 * @Description: 变量提升
 * @Author: wangyi
 * @Date: 2019-09-05 11:06:08
 * @LastEditTime: 2019-09-08 16:57:20
 * @LastEditors: Please set LastEditors
 -->

# 关于变量提升

## 为什么会存在变量提升

**我觉得这个问题需要先去讨论一下编译原理。在传统编译语言中，一段程序通常会经历三个步骤：**

1. **分词/词法分析**

   - 将字符组成的字符串分解为对编程语言来说**有意义的代码块(词法单元)**

2. **解析/语法分析**

   - 将上面的词法单元流转换为一个由元素逐级嵌套所组成的代表了程序语法结构树，这个树叫抽象语法树(AST--Abstract Syntax Tree)

3. **代码生成**
   - 将上面的 AST 转换为程序可执行的代码

**将上面的步骤放到 JavaScript 中我们来解释一下编译过程，当然实际的 js 编译过程要比这个复杂。**

1. `var a = 2;`会被分解为`var`、`a`、`=`、`2`、`;`以上的词法单元，这些松散的词法单元会组成词法单元流，然后进行解析。
2. 将上面的这堆词法单元流，转换成 AST。

   - 初始化

   ```javascript
   {
     "type": "Program",
     "start": 0,
     "end": 0,
     "body": [],
     "sourceType": "module"
   }
   ```

   - 解析时

   ```javascript
     {
       "type": "Program",
       "start": 0,
       "end": 10, //结束时的位置
       "body": [
         {
           "type": "VariableDeclaration", //类型为变量声明
           "start": 0,
           "end": 10,
           "declarations": [
             {
               "type": "VariableDeclarator",
               "start": 4,
               "end": 9,
               "id": {
                 "type": "Identifier",
                 "start": 4,
                 "end": 5,
                 "name": "a" //变量名
               },
               "init": {
                 "type": "Literal",
                 "start": 8,
                 "end": 9,
                 "value": 2, //该变量的值
                 "raw": "2"
               }
             }
           ],
           "kind": "var"
         }
       ],
     "sourceType": "module"
   }
   ```

3. 将上面的 AST 转换成可执行的代码
